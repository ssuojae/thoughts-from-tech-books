
### Chapter01. Building Event-Driven Microservices 주요문장

<br/>

<img width="400" alt="image" src="https://github.com/user-attachments/assets/174890ed-f697-4505-b662-56dc775100af">

>The services themselves are small and purpose-built, created to help fulfill the necessary business goals of the organization.

>In contrast, it's reare for a company to need to change the underlying implementation of any given product without accompanying business requirement changes. This is why vounded contexts should be built around business requirements and not technological requirements.

>Databases may provide read-only replicas; however, this can expose their inner data models unnecessarily. Batch processes can dump data to a file store to be read by other processes, but this approach can create issues around data consistency and multiple sources of truth.

<br/>
<img width="400" alt="image" src="https://github.com/user-attachments/assets/5e65a314-39c7-4f53-81fa-316ddacca851">


> Modeling event-driven microservices architectures around business requirements is preferred, though there are tradeoffs with this approach. Code may be replicated a number of times, and many services may use similar data access patterns. 


>This quote, known as Conway’s law, implies that a team will build products according to the communication structures of its organization.

>One of the tenets of event-driven microservices is that core business data should be easy to obtain and usable by any service that requires it.

>An event-streaming data communication structure decouples the productino and ownership of data from the access to it.

>Nearly anything can be communicated as an event, from sinple occurences to complex, stateful records. Events are the data; they are not merely singals indicating data is ready elsewhere or just a means of direct data transfer from one implementation to another. Rather, they act both as data storage and as a means of asynchronous communication between services.

>However, any data that is of interest to any other team or service must be published to the common set of event streams, such that the production and ownership of data becomes fully decoupled.



<br/>
<br/>


### Chapter01. Building Event-Driven Microservices 나의 생각

<br/>

- MSA는 좀 더 광의의 객체지향이라는 느낌을 받을 수 있었다. 이전에는 코드단위에서 서로 연관된 걸 묶고 각 객체와의 대화를 통해 객체지향 프로그래밍을 했다면 각 객체들의 묶음인 모듈이 하나의 서비스를 맡고 각각의 서비스들의 대화를 통해 비즈니스 로직을 푸는 것 같았기 때문이다.
- 프로젝트에서 역할분배를 할 때 항상 두번째 사진을 고려하게 되는 것 같다. 하지만 책을 읽으면서 오른쪽 (cross-cutting ownership)으로 분배를 하게되면 자연스럽게 "도메인 로직" 보다는 "기술적인 로직"을 따르게 된다는 것을 알 수 있었다.
- 그렇다고 왼쪽(Sole ownership)이 무조건 좋은 것만은 아니다. 결국 이것도 트레이드 오프 관계.
- 콘웨이 법칙(Conway's law) -> 결국 팀의 의사소통 구조에 따라 결과물이 만들어진다
- 이벤트를 데이터라는 관점으로 봐야한다는 것이 인상깊었다. 단순히 무언가를 트리거하는 것이 아닌 이벤트는 비동기적 의사소통 데이터이다.

<br/>
<br/>

#

### Chapter02. Building Event Driven Microservices 주요문장

<br/>

>The term topology comes up frequently in discussions of event-driven microservices. This term is often used to mean the processing logic of an individual microservice.

<br/>

<img src="https://github.com/user-attachments/assets/2d0b7471-e7d7-4f2c-a1fe-e403d641bd5e" width="400">

<br/>

>Meanwhile, event stream B is ingested, and certain events are filterd out, transformed, and then joined  against the stored state.

<br/>

>Though not a definitive standard, commonly available event borkers use an append-only immutable log.

<br/>

<img src="https://github.com/user-attachments/assets/3dc470b9-b64e-4b73-b6a0-4dd521cd7f4e" width="400">

<br/>

<img src="https://github.com/user-attachments/assets/7ab15d37-8612-41b1-b585-fb9b8a8e438b" width="400">

<br/>

>The consumer group allows for multiple consumers to be viewed as the same logical entity and can be leveraged for horizontal scaling of message consumption.

<br/>

>





<br/>
<br/>


### Chapter02. Building Event Driven Microservices 

<br/>

- 메세지 브로커와 이벤트 브로커의 차이를 알 수 있었다. 메세지 브로커는 택배서비스와 같다. producer가 이벤트를 생성해서 큐에 넣으면 FIFO방식으로 알맞은 Consumer가 소비해간다. 반면 이벤트 브로커는 "이벤트" 자체를 데이터 로그로 여기고 producer는 이벤트가 발생했을 때 이벤트를 "발행(publish)"한다. 즉 이벤트를 로그로 쌓아둔다. consumer는 쌓아둔 로그중 원하는걸 "구독(subscribe)" 한다. 구독이라는 단어에서 알 수 있듯이 데이터 전달이 스트림으로 이루어진다.
- 메세지 브로커는 큐 자료구조를 사용하기 때문에 실시간 처리, 작업 대기열 등 작업을 각 MS에게 분산처리할 때 적합하고 이벤트 브로커는 "이벤트" 데이터를 장기간 보존해서 재사용하거나 여러 소비자가 동일한 이벤트를 독립적으로 처리하는 경우에 적합하다고 볼 수 있다. 약간 작동방식이 메세지 브로커는 싱글 스레드, 이벤트 브로커는 멀티 스레드 같다는 인상을 받았다.
- 또하나의 인상은 메세지 브로커는 시스템의 동작 순서에 종속되지만 이벤트 브로커는 개발자가 의도하고싶은 "행위"기반이라는 것이었다. 클린아키텍쳐 책에서 IoC를 한 이유가 시스템 동작순서가 아닌 객체 행위에 주도권을 갖기 위함이라는 문구가 있었는데 이벤트브로커도 이와 비슷하다는 인상을 받았다.
- 이벤트 브로커의 장점은 컨슈머가 여러 이벤트를 동시에 구독할 수 있다.
- 모바일 프로그래밍에서 자주봤던 SSOT(Single Source Of Truth)가 이곳에서도 등장하고 있었다. 백엔드 MSA에서 SSOT는 이벤트 큐로 정해서 처리하고 있었다.
- 

















