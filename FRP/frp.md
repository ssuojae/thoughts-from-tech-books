![image](https://github.com/user-attachments/assets/9efd1289-e244-44b2-8993-72ca80e192c4)

**목차**

1.  Stop listening!
2.  Core FRP
3.  Some everyday widget stuff
4.  Writing a real application
5.  New concepts
6.  FRP on the web
7.  Switch
8.  Operational primitives
9.  Continuous time
10.  Battle of the paradigms
11.  Programming in the real world
12.  Helpers and patterns
13.  Refactoring
14.  Adding FRP to existing projects
15.  Future directions

---

<br/>
<br/>

### **Chapter 1. Stop Listening** 

**Stop Listening 챕터는 Functinoal Reactive Programming 의 탄생 배경과 얻을 수 있는 장점에 대해 소개하는 내용이었다.**

![image](https://github.com/user-attachments/assets/09ed3bcc-85b7-4b56-9eaf-dae31db3884f)

프로그램은 상태관리 기계이다. 인풋이 들어가면 로직에의해 상태가 변경되고 변경된 상태를 아웃풋으로 배출한다.

프로그래밍의 어려움은 이러한 상태관리에서 비롯된다. 인풋과 로직, 아웃풋은 예측가능하지만 state가 언제 어떻게 바뀌는지는 코드가 복잡해지면 인식하기 어려워지기 때문이다. 

또한 각 개별 구현체에서 일어나는 버그들은 사실상 구현 자체가 문제가 아닌 구조가 문제일 경우가 많다.

좋은 구조는 거의 대부분의 에러발생 가능성을 잡아줄 수 있다.

오늘날까지 상태관리 구조에 있어서 세 단계 국면이 있었다.

**첫번째는 OOP없이 그냥 명령을 꼬리에 꼬리를 물어 실행시키던 시절**

**두번째는 OOP 개념의 등장과 함께 상태관리를 중앙에서 관리하고 나머지 객체는 변화를 "Listen" 하는 옵저버패턴과 콜백**

**세번째는 함수형 프로그래밍 개념의 등장과 함께 나온 함수형, 반응형 프로그래밍이다.**

첫번째에서 두번째로 넘어오는 과정은 OOP 개념이기 때문에 생략하고 두번째에서 세번째로 넘어가는 과정에 대해 이야기 해보고자 한다.

<img src="https://github.com/user-attachments/assets/7fe6dac7-8941-4efa-a4b6-8f5e4c291f0b" width="300">

기존 옵저버패턴/콜백을 통한 상태관리는 어떤 점이 문제이었을까? 이 책에서는 6가지 문제점을 지적한다.

**첫번째, 상태관리 순서에 영향을 받는다.**

**두번째, 첫번째 이벤트를 유실할 수 있다.**

**세번째, 상태 관리가 난잡해진다.**

**네번째, 스레드 이슈를 발생시킨다.**

**다섯번째, 메모리 누수가 발생할 수 있다.**

**여섯번째, 상태 변경에 무한 재귀가 발생할 수 있다.**

여섯가지 이슈에 대해 차례대로 살펴보자

<br/>

```swift
class EventManager {
    private var listeners = [(Int) -> Void]()

    func addListener(_ listener: @escaping (Int) -> Void) {
        listeners.append(listener)
    }

    func triggerEvent(value: Int) {
        for listener in listeners {
            listener(value)
        }
    }
}

let manager = EventManager()

// 리스너 등록
manager.addListener { value in
    print("처리 A: \(value)")
}

manager.addListener { value in
    print("처리 B: \(value)")
}

// 이벤트 발생
manager.triggerEvent(value: 5)
```

먼저 옵저버 패턴/콜백을 통한 상태관리는 구독한 순서에 따라 상태변화가 전파되기 때문에 순서에 따라 영향을 받는다

위 코드에서는 A 와 B 리스너를 등록하는 옵저버 패턴이다. 옵저버들은 등록된 순서대로 알림을 받는다. 첫 번째 옵저버가 상태를 변경할 경우, 그 변경이 후속 옵저버의 반응에 영향을 줄 수 있다. 따라서, 상태 변경의 순서에 의해 사이드 이펙트를 야기할 수 있음을 의미한다.

<br/>

```swift
import RxSwift

let disposeBag = DisposeBag()
let subject = PublishSubject<Int>()

// 첫 번째 구독자
subject
    .subscribe(onNext: { value in
        print("처리 A: \(value)")
    })
    .disposed(by: disposeBag)

// 두 번째 구독자
subject
    .subscribe(onNext: { value in
        print("처리 B: \(value)")
    })
    .disposed(by: disposeBag)

// 이벤트 발생
subject.onNext(5)
```

위 Rx코드에서는 각 구독자가 독립적이라는 것이다. RxSwift의 Observable 이라는 이벤트 스트림은 각 구독자에게 독립적으로 데이터를 전달하며, 구독자들은 서로의 처리 결과에 영향을 받지 않는다. 각 구독자가 자신이 받은 데이터에 대해서만 반응하고, 다른 구독자의 동작 방식이나 순서에 의존하지 않는다는 점에서 순서에 영향을 받지않는 독립적인 이벤트 처리를 수행한다.

<br/>

```swift
import Combine

// 1. CurrentValueSubject 생성 (초기값 0)
let subject = CurrentValueSubject<Int, Never>(0)

// 2. 첫 번째 이벤트 발생
subject.send(1)

// 3. 구독자 등록 후 바로 이전 이벤트(1)를 받음
let subscription = subject.sink(receiveValue: { value in
    print("구독자가 받은 값: \(value)")
})

// 4. 두 번째 이벤트 발생
subject.send(2)

// 5. 구독 해제
subscription.cancel()
```

두번째, 미리 발생한 이벤트 소실은 OOP 프로그래밍 하다보면 자주 발생하는 문제이다. 당연한 이야기지만 옵저버패턴에서 리스너를 등록하기 전에 상태변화를 방출한 후에 리스너를 등록하면 등록된 리스너는 이전 이벤트를 전혀 알 수 없다. 하지만 위와 같이 FRP는 미리 발생한 이벤트라도 구독자가 알 수 있다. Rx를 예로 들자면 Observable 이란 강줄기를 만들고 여기서 변화된 값을 구독자가 받아서 처리하는 것이기 때문에 강줄기에 등록된 이벤트들을 어떻게든 가져와서 쓸 수 있는 것이다. (여기서 모든 이벤트들을 메모리 상에 안두기 위해 이터레이터 패턴의 Stream 개념과 같이 동작한다.)

<br/>

```
// MARK: - Observer Pattern

      +-------------+
      |   Subject   |
      +-------------+
         ^     ^     ^
        /     / \     \
       /     /   \     \
+----------+ +----------+ +----------+
| Observer | | Observer | | Observer |
+----------+ +----------+ +----------+


// MARk: - FRP

+--------+      +--------+      +--------+
| Source | ---> | Stream | ---> |  Cell  |
+--------+      +--------+      +--------+
                   |                |
                   v                v
               +--------+       +--------+
               |  Comp  |       |  Comp  |
               +--------+       +--------+
                   |                |
                   v                v
               +--------+       +--------+
               |  Comp  |       |  Comp  |
               +--------+       +--------+
```

세번째는 상태관리가 난잡해진다는 것은 다시 말해, FRP를 활용하면 상태변화가 단방향으로 흐르며 선언적이기 때문에 당연히 변화된 상태도 툭툭 독립적으로 나와 처리한다.  반면 옵저버 패턴은 양방향으로 중앙 옵저버에 있는 상태에 접근해서 변경후 전달받기 때문에 의존성 관계가 FRP에 비해 난잡해질 수 밖에 없다.

네번째는 이전과 연결된다. 옵저버 패턴에서는 옵저버들이 모두 상태에 직접 접근해서 변화를 주고 전파되기 때문에 Race Condition에 노출될 수 있다. 

다섯번째 옵저버패턴에서 리스너를 등록하지 않고 제거하지 않으면 메모리 누수가 발생한다. FRP와 다르게 옵저버패턴의 리스너는 스스로 자신을 리스너로 지우지 못하고 중앙에서 제거를 모두 관리해주어야하기 때문에 메모리 누수의 위험이 증가한다.

여섯번째 무한재귀는 FRP에서 거의 일어나기 힘든데 바로 스트림이라는 이벤트 흐름이 명확하고 각 구독자가 받는 상태는 **격리되기** 때문이다.

---

<br/>

<img src="https://github.com/user-attachments/assets/848b8ec8-7c08-4d2a-a4e0-38634bb64e04" width="300">

기존 OOP의 상태관리 패턴인 옵저버 패턴과 콜백 메서드의 한계를 살펴보았다. 그럼 이제 FRP에 좀더 알아보자

FRP의 핵심 특징은

1\. **단방향 데이터 흐름**이다.(보통 Stream이라 표현한다) 

2\. 인풋값(이벤트)에 반응한다. (Reactive 특징)

3\. 선언형이다. 사실상 선언형 함수 파라미터로 인풋이 들어가 아웃풋을 배출한다.

위 3가지 특징이 함의하는 바가 무엇일까?

일종의 순수함수 개념과 일맥상통하는데 우리가 관리해줄 건 인풋과 아웃풋을 어떻게 다룰지이고 내부 비즈니스 로직을 캡슐화 할 수 있다는 것이다.  다시말해 이벤트를 기반으로 우리가 쓰는 프로그래밍 언어를 순수 로직 설정으로만 사용할 수 있다는 것이다. 책에서는 자바, 자스, 스위프트 같은 프로그래밍 언어를 "**메타언어(하나의 언어를 조작하기 위해 사용되는 다른언어)**" 로 쓸 수 있다고 표현한다.

이를 통해 개발자는 프로그래밍 할 때 "**어떻게(how)**"에 집중하는 것이 아닌 "**무엇(what)**"을 만들어낼 것인 가에 집중할 수 있다. 비즈니스 로직은 블랙박스처럼 캡슐화되고 오직 인풋과 아웃풋을 어떤 물줄기 방향으로 설정하는지 고민하면 되기 때문이다.

개발자는 더이상 시시콜콜한 객체 내부를 어떻게 만들고 어떻게 사용할지에 고민하는 것이 아닌 추상화된 비즈니스 로직(객체 생성 위한 내부 로직)을 캡슐화된 순수함수를 사용해서 객체를 어떤 로직으로 이벤트에 반응하여 블록 쌓기를 한뒤 원하는 바를 만들어낼 것인지에만 집중한다. 즉 이벤트 베이스 로직에 시간을 집중시킬 수 있다.

---

<br/>
<br/>

### **Chapter 2. Stop Listening** 

<img src="https://github.com/user-attachments/assets/35c0851f-e592-4870-b94b-798ca43664b0" width="450">

챕터 2에서 인상깊었던 점은 세가지였다. 첫째, FRP는 결국 "이벤트 스트림"과 스트림으로 부터 나오는 값을 받는 "셀"로 이루어진다. 둘째, FRP는 태생적으로 I/O 로 부터 날아오는 이벤트를 반응할 수 밖에 없다. 셋째, 순수함수와 참조투명성을 지키기 위해서는 I/O 작업을 분리해야한다. (I/O작업은 예측 불가능하기 때문에). 나중에 FRP코드를 짤 때는 I/O작업을 하는 인터페이스는 팩토리 형태 메서드로 만들어 새로운 스트림을 만들어내고 내부 이벤트처리는 같은 스트림을 사용해서 처리하면 되겠다라는 생각을 했다.

---

<br/>
<br/>

### **Chapter 4. Writing a real application (Ch3 생략)**

ch3 는 인상깊은 문장이 없어서 (~이해하지 못해서~) 넘어갔다 🥹

<img src="https://github.com/user-attachments/assets/0eb318c4-ed46-497d-be10-89c302369913" width="350">

이번 챕터에서 배운점은 4가지이다.

1\. FRP 할 때는 불변성이 핵심이기 때문에 상태 변화에 있어 메모리 주소내 값을 바꾸는 게 아니라 상태가 바뀔 때마다 새로운 메모리 주소를 할당하는 복사가 이루어진다. **따라서 변화하는 상태 변수라도 상수(자바는 final, 스위프트는 let)로 선언**해야한다.

2\. FRP에 사용되는 클래스는 OOP에서 사용된 상태관리가 아닌 그냥 **접근제한 범위 및 연관된 정보를 묶기위해**서 사용한다.

3\. FRP의 장점을 극대화 시키려면 **Input 스트림과 Ouput 스트림을 묶어서 분리시키는 것이 좋다**는 것을 알았다. 이는 iOS에서 UIKit+MVVM의 인풋아웃풋 패턴에서 흔히 사용되는 것과 같은 맥락이다. 이렇게 인풋아웃풋이 명확해지니 테스트하기 편해진다.

4\. FRP는 모든 액션에 반응되기 때문에 스트림 및 로컬변수가 많아질 수 밖에 없다. 의미있는 네이밍과 함께 컨테이너화 시켜버리는 것이 좋다. 

---

<br/>
<br/>

### **Chapter 5.  New Concepts**

FRP 에 대한 생각을 컴퓨터 구조의 변천과 연관지어 설명한다는 점에서 인상깊었다.

이 책에서 설명한 컴퓨터 구조의 변화에 대해서 알아보면

-   **폰 노이만 아키텍처**: 프로세서가 메모리에서 명령을 읽어와 실행하여 메모리의 데이터를 조작  
    메모리와 프로세서는 버스로 연결된 별개 엔티티  
      
    
-   **현대 컴퓨터**: 캐시 메모리를 사용하여 자주 접근하는 데이터를 빠르게 처리. 링크드 리스트의 노드가 메모리에서 인접해 있을 때 **캐시 히트**( CPU가 필요한 데이터가 캐시 메모리에 이미 저장되어 있는 경우) 가 발생하여 성능이 향상. 하지만 노드가 무작위로 배치되면 **캐시 미스**가 발생하여 성능이 크게 저하된다. 현대에는 이를 보완한 NUMA 구조가 사용되고 있다.

<br/>

폰 노이만 아키텍쳐가 현대까지 오지 못한 이유는 병렬처리에 대한 어려움 때문이다.  CPU와 메모리는 단일 버스로 연결되어 모든 데이터와 명령어가 이 버스를 통해 이동해야 하기 때문에 명령어를 순차적으로 처리하게 되어 병렬처리가 어려웠다.

앞서 현대 컴퓨터는 캐시 메모리를 이용한다고 했었다. 이러한 캐시 관리는 멀티 프로세서 환경에서 다소 복잡해지는 데 여러 프로세서가 동시에 메모리에 접근할 때 발생하는 충돌을 해결했어야만 했다. 이러한 의도의 일환으로 등장한 것이 **NUMA Architecture** 이다.

NUMA는 모든 프로세서가 메모리와 입출력 장치에 동일한 속도로 접근하는 기존의 UMA(Uniform Memory Access) 아키텍처의 단점을 극복하기 위해 개발되었다. NUMA는 메모리 접근 속도가 프로세서와 메모리 간의 물리적 거리 및 연결에 따라 달라지는 구조를 가지고 있다. Numa 에서는 각 프로세서(또는 프로세서 노드)는 자체 로컬 메모리를 가지고 있게 된다. 

<img src="https://github.com/user-attachments/assets/ea418d48-72fb-4d72-8eb5-fa4cbe9d350c" width="350">
<img src="https://github.com/user-attachments/assets/1f2af89a-34e1-400e-8f43-dd1be33fe9e0" width="350">

<br/>

문제는 **우리가 쓰고 있는 프로그래밍 언어가 폰 노이만 아키텍쳐 시절에 만들어진 형태(C언어) 를 쓰고 있다는 것이다**. 폰 노이만 아키텍쳐처럼 우리는 프로그래밍할 때 메서드가 데이터를 변형시키고 이를 읽는 작업을 하고 있다. 이러한 "State Mutation" 방식은 현대 컴퓨터 구조 (각 프로세싱 유닛이 캐싱을 가지고 있는 구조)와 어울리지 않으며 이러한 방식의 가장 큰 문제점은 **데이터에 의존성을 가지고 있는 작업들 간의 관계가 복잡해질 수 밖에 없다는 것**이다. 

FRP는 기존 폰노이만 아키텍쳐를 넘어 NUMA 와 같이 각각의 프로세스가 일종의 캐시 데이터를 들고 있는 형태가 된다. 이러한 구조로써 얻을 수 있는 장점은 Compostionting이 된다는 것이다. 각각의 프로세스를 하나의 블록단위로 생각하여 큰 문제를 해결하는데 용이해진다. FRP에서는 작은 블록 단위들이 많아질 수록 복잡성이 감소한다. (확상성 크게 증가)

당연한 이야기지만 큰 건물을 짓기위해 작은 블록 단위들을 쌓아야한다면(함수 합성), 작은 블록 단위들은 반드시 예측 가능한 결과만이 나와야한다. 그래서 FRP에서 **순수함수**와 **참조투명성**이 중요시된다. 이렇게 예측가능하고 불변한 블록들이 모여 건물을 짓는다면 해당 건물은 버그없이 굉장히 튼튼하게 지을 수 있다.

FRP는 또 하나의 장점이 있는데 바로 로직이 명확해진다는 것이다. FRP를 한다는 것은 개별 프로세스 그 자체를 프로그래밍한다는 것이다. 이러한 구조로 인해 기존 OOP에서는 로직 구현에 있어 클래스와 같은 범위제약이 걸렸다면 FRP에서는 프로세스의 end to end 그 자체를 프로그래밍할 수 있다. 즉 코드를 읽는 사람으로 하여금 각 프로세스의 "명확한 의도"를 인식시켜 줄 수 있다.

FRP의 장점을 극대화 시켜주는 방법은 바로 추상화 인터페이스 메서드 활용이다. 물론 추상화 뒤에 숨은 의미를 이해하기 어려울 수 있다는 단점이 있지만 추상화를 통한 명확한 의도 제시와 재사용성이라는 장점에 비하면 사소하다고 책에서 주장한다.
